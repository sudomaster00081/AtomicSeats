<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé¨ Seat Management Test UI</title>
    <style>
        :root {
            --available: #2ecc71;
            --held: #f39c12;
            --booked: #e74c3c;
            --selected: #3498db;
            --expired: #95a5a6;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        body { background: #f5f7fa; color: #333; padding: 20px; max-width: 1200px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 25px; padding: 15px; background: white; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.08); }
        h1 { color: #2c3e50; margin-bottom: 8px; font-size: 2.2rem; }
        .subtitle { color: #7f8c8d; font-size: 1.1rem; }
        .container { display: grid; grid-template-columns: 1fr 350px; gap: 25px; }
        .seat-container { background: white; border-radius: 12px; padding: 25px; box-shadow: 0 4px 15px rgba(0,0,0,0.08); }
        .stats-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px 0; }
        .stat-card { background: #f8f9fa; border-radius: 10px; padding: 15px; text-align: center; border-left: 4px solid #3498db; }
        .stat-card.available { border-left-color: var(--available); }
        .stat-card.held { border-left-color: var(--held); }
        .stat-card.booked { border-left-color: var(--booked); }
        .stat-value { font-size: 2.2rem; font-weight: bold; margin: 5px 0; color: #2c3e50; }
        .stat-label { color: #7f8c8d; font-size: 0.95rem; }
        .seat-grid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 8px; margin-top: 20px; }
        .seat-row-label { grid-column: 1; text-align: center; font-weight: bold; padding: 8px 0; color: #555; }
        .seat { aspect-ratio: 1; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-weight: bold; cursor: pointer; transition: all 0.2s ease; user-select: none; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .seat.available { background: var(--available); color: white; }
        .seat.held { background: var(--held); color: white; position: relative; }
        .seat.booked { background: var(--booked); color: white; cursor: not-allowed; opacity: 0.85; }
        .seat.selected { background: var(--selected); color: white; transform: scale(1.1); box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.4); }
        .seat.expired { background: var(--expired); color: white; }
        .seat:hover:not(.booked):not(.held) { transform: scale(1.05); }
        .seat .timer { position: absolute; bottom: -20px; left: 0; right: 0; font-size: 0.7rem; color: #c0392b; font-weight: bold; text-shadow: 0 1px 2px rgba(255,255,255,0.8); }
        .actions { display: flex; flex-direction: column; gap: 15px; margin-top: 25px; }
        button { padding: 14px 20px; border: none; border-radius: 10px; font-size: 1.05rem; font-weight: 600; cursor: pointer; transition: all 0.2s; }
        button:disabled { opacity: 0.6; cursor: not-allowed; }
        .btn-hold { background: var(--held); color: white; }
        .btn-book { background: var(--available); color: white; }
        .btn-release { background: #9b59b6; color: white; }
        .btn-refresh { background: #3498db; color: white; }
        .btn-simulate { background: #e67e22; color: white; }
        button:hover:not(:disabled) { opacity: 0.9; transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
        .control-panel { background: white; border-radius: 12px; padding: 25px; box-shadow: 0 4px 15px rgba(0,0,0,0.08); height: fit-content; }
        .panel-section { margin-bottom: 25px; }
        .panel-section h2 { color: #2c3e50; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #ecf0f1; font-size: 1.4rem; }
        .form-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 6px; font-weight: 500; color: #2c3e50; }
        input, select { width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 1rem; }
        input:focus, select:focus { outline: none; border-color: #3498db; }
        .notification { position: fixed; top: 20px; right: 20px; padding: 16px 25px; border-radius: 10px; color: white; font-weight: 500; box-shadow: 0 5px 15px rgba(0,0,0,0.2); z-index: 1000; transform: translateX(400px); transition: transform 0.3s ease-out; }
        .notification.show { transform: translateX(0); }
        .notification.success { background: var(--available); }
        .notification.error { background: var(--booked); }
        .notification.info { background: #3498db; }
        .simulation-area { background: #f8f9fa; border-radius: 10px; padding: 15px; margin-top: 15px; }
        .simulation-log { height: 150px; overflow-y: auto; font-family: monospace; font-size: 0.9rem; background: #2c3e50; color: #2ecc71; padding: 10px; border-radius: 8px; white-space: pre-wrap; }
        .active-holds { margin-top: 20px; }
        .hold-item { background: #f1f8ff; border-left: 4px solid var(--held); padding: 12px; border-radius: 0 8px 8px 0; margin-bottom: 10px; font-size: 0.95rem; }
        .hold-item.expired { border-left-color: var(--expired); opacity: 0.7; }
        .hold-seats { font-weight: bold; color: #2c3e50; }
        .hold-timer { color: var(--booked); font-weight: bold; float: right; }
        .screen { text-align: center; margin: 25px 0 15px; position: relative; }
        .screen::before { content: "SCREEN"; display: inline-block; padding: 8px 25px; background: #34495e; color: white; border-radius: 20px; font-weight: bold; letter-spacing: 2px; }
        .screen::after { content: ""; display: block; width: 100%; height: 5px; background: #34495e; margin-top: 10px; border-radius: 3px; }
        .health-status { display: flex; align-items: center; gap: 8px; margin-top: 10px; font-weight: 500; }
        .health-dot { width: 12px; height: 12px; border-radius: 50%; background: #95a5a6; }
        .health-dot.healthy { background: var(--available); }
        .health-dot.unhealthy { background: var(--booked); }
        footer { text-align: center; margin-top: 30px; color: #7f8c8d; font-size: 0.9rem; padding: 20px; border-top: 1px solid #eee; }
        @media (max-width: 900px) {
            .container { grid-template-columns: 1fr; }
            .seat-grid { grid-template-columns: repeat(8, 1fr); }
        }
        @media (max-width: 600px) {
            .stats-grid { grid-template-columns: 1fr; }
            .seat-grid { grid-template-columns: repeat(6, 1fr); }
            .seat-row-label { display: none; }
            .actions { flex-direction: row; flex-wrap: wrap; }
            button { flex: 1; min-width: 120px; }
        }
    </style>
</head>
<body>
    <header>
        <h1>üé¨ Seat Management System</h1>
        <div class="subtitle">Concurrency-safe seat booking backend test interface</div>
        <div class="health-status">
            <div class="health-dot" id="health-dot"></div>
            <span id="health-text">Checking system health...</span>
        </div>
    </header>

    <div class="container">
        <div class="seat-container">
            <div class="stats-grid">
                <div class="stat-card available">
                    <div class="stat-value" id="available-count">--</div>
                    <div class="stat-label">Available Seats</div>
                </div>
                <div class="stat-card held">
                    <div class="stat-value" id="held-count">--</div>
                    <div class="stat-label">Held Seats</div>
                </div>
                <div class="stat-card booked">
                    <div class="stat-value" id="booked-count">--</div>
                    <div class="stat-label">Booked Seats</div>
                </div>
            </div>

            <div class="screen"></div>
            
            <div id="seat-grid" class="seat-grid">
                <!-- Seats dynamically populated -->
            </div>

            <div class="actions">
                <button id="hold-btn" class="btn-hold" disabled>‚è≥ Hold Selected Seats (10 min)</button>
                <button id="book-btn" class="btn-book" disabled>‚úÖ Book Held Seats</button>
                <button id="release-btn" class="btn-release" disabled>üîÑ Release Hold</button>
                <button id="refresh-btn" class="btn-refresh">‚ü≥ Refresh Status</button>
                <button id="simulate-btn" class="btn-simulate">‚ö° Simulate 10 Concurrent Users</button>
            </div>
        </div>

        <div class="control-panel">
            <div class="panel-section">
                <h2>Show Management</h2>
                <div class="form-group">
                    <label for="show-select">Select Show</label>
                    <select id="show-select">
                        <option value="avengers_2026_7pm">Avengers: Endgame (Demo)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="new-show-id">New Show ID</label>
                    <input type="text" id="new-show-id" placeholder="e.g., spiderman_2026_9pm">
                </div>
                <div class="form-group">
                    <label for="seat-layout">Seat Layout (rows x columns)</label>
                    <select id="seat-layout">
                        <option value="5x10">5 rows √ó 10 seats (50 seats)</option>
                        <option value="8x12">8 rows √ó 12 seats (96 seats)</option>
                        <option value="10x15">10 rows √ó 15 seats (150 seats)</option>
                    </select>
                </div>
                <button id="init-show-btn" style="width:100%; background:#27ae60; color:white; padding:12px; font-weight:bold;">‚ûï Initialize New Show</button>
            </div>

            <div class="panel-section active-holds">
                <h2>Active Holds</h2>
                <div id="holds-list">
                    <div class="hold-item">No active holds</div>
                </div>
            </div>

            <div class="panel-section">
                <h2>Concurrency Simulation</h2>
                <div class="simulation-area">
                    <div class="simulation-log" id="simulation-log">Simulations will appear here...</div>
                </div>
            </div>

            <div class="panel-section">
                <h2>System Notes</h2>
                <ul style="padding-left: 20px; line-height: 1.6; color: #555;">
                    <li>‚úÖ <strong>Green</strong> = Available seat</li>
                    <li>‚è≥ <strong>Orange</strong> = Held by someone (expires in 10 min)</li>
                    <li>‚ùå <strong>Red</strong> = Already booked</li>
                    <li>üîµ <strong>Blue</strong> = Your selection (client-side only)</li>
                    <li>Seats auto-release after 10 minutes if not booked</li>
                    <li>Concurrent bookings are safely handled by backend</li>
                </ul>
            </div>
        </div>
    </div>

    <div id="notification" class="notification"></div>

    <footer>
        <p>Backend: Flask (in-memory) ‚Ä¢ UI for testing concurrency safety ‚Ä¢ <strong>Refresh page to reset client state</strong></p>
        <p style="margin-top: 8px; font-style: italic; color: #95a5a6;">‚ö†Ô∏è In-memory limitation: All bookings reset on server restart</p>
    </footer>

    <script>
        // ======================
        // CORE APPLICATION STATE
        // ======================
        const API_BASE = 'http://localhost:5000';
        let currentShowId = 'avengers_2026_7pm';
        let seatMap = {}; // { seatId: { status, holdExpiresAt } }
        let selectedSeats = new Set();
        let currentHoldId = null;
        let holdExpiryTime = null;
        let refreshInterval = null;
        let simulationLog = [];

        // ======================
        // DOM ELEMENTS
        // ======================
        const elements = {
            seatGrid: document.getElementById('seat-grid'),
            availableCount: document.getElementById('available-count'),
            heldCount: document.getElementById('held-count'),
            bookedCount: document.getElementById('booked-count'),
            holdBtn: document.getElementById('hold-btn'),
            bookBtn: document.getElementById('book-btn'),
            releaseBtn: document.getElementById('release-btn'),
            refreshBtn: document.getElementById('refresh-btn'),
            simulateBtn: document.getElementById('simulate-btn'),
            showSelect: document.getElementById('show-select'),
            newShowId: document.getElementById('new-show-id'),
            seatLayout: document.getElementById('seat-layout'),
            initShowBtn: document.getElementById('init-show-btn'),
            holdsList: document.getElementById('holds-list'),
            simulationLog: document.getElementById('simulation-log'),
            notification: document.getElementById('notification'),
            healthDot: document.getElementById('health-dot'),
            healthText: document.getElementById('health-text')
        };

        // ======================
        // UTILITY FUNCTIONS
        // ======================
        function showToast(message, type = 'info') {
            elements.notification.textContent = message;
            elements.notification.className = `notification ${type} show`;
            setTimeout(() => {
                elements.notification.classList.remove('show');
            }, 3000);
        }

        function formatSeatId(row, col) {
            return `${String.fromCharCode(65 + row)}${col + 1}`; // A1, A2, etc.
        }

        function parseSeatLayout(layout) {
            const [rows, cols] = layout.split('x').map(Number);
            return { rows, cols };
        }

        function getTimeRemaining(expiryTime) {
            if (!expiryTime) return null;
            const now = new Date();
            const diff = new Date(expiryTime) - now;
            if (diff <= 0) return 'Expired';
            
            const mins = Math.floor(diff / 60000);
            const secs = Math.floor((diff % 60000) / 1000);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        async function apiRequest(url, options = {}) {
            try {
                const response = await fetch(`${API_BASE}${url}`, {
                    ...options,
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    }
                });
                
                if (!response.ok) {
                    const error = await response.json().catch(() => ({ error: 'Unknown error' }));
                    throw new Error(error.error || `HTTP ${response.status}`);
                }
                
                return await response.json();
            } catch (error) {
                showToast(`API Error: ${error.message}`, 'error');
                console.error('API Error:', error);
                throw error;
            }
        }

        // ======================
        // SEAT RENDERING
        // ======================
        function renderSeatGrid() {
            elements.seatGrid.innerHTML = '';
            const layout = parseSeatLayout('5x10'); // Default layout
            
            // Add row labels
            for (let row = 0; row < layout.rows; row++) {
                const label = document.createElement('div');
                label.className = 'seat-row-label';
                label.textContent = String.fromCharCode(65 + row);
                elements.seatGrid.appendChild(label);
                
                // Add seats for this row
                for (let col = 0; col < layout.cols; col++) {
                    const seatId = formatSeatId(row, col);
                    const seatData = seatMap[seatId] || { status: 'available' };
                    const seatEl = document.createElement('div');
                    seatEl.className = `seat ${seatData.status}`;
                    seatEl.dataset.seatId = seatId;
                    seatEl.textContent = col + 1;
                    
                    // Add timer for held seats
                    if (seatData.status === 'held' && seatData.holdExpiresAt) {
                        const timerEl = document.createElement('div');
                        timerEl.className = 'timer';
                        timerEl.textContent = getTimeRemaining(seatData.holdExpiresAt);
                        seatEl.appendChild(timerEl);
                    }
                    
                    // Selection state
                    if (selectedSeats.has(seatId)) {
                        seatEl.classList.add('selected');
                    }
                    
                    // Interaction
                    if (seatData.status !== 'booked') {
                        seatEl.addEventListener('click', () => toggleSeatSelection(seatId));
                    }
                    
                    elements.seatGrid.appendChild(seatEl);
                }
            }
            
            // Update hold button state
            elements.holdBtn.disabled = selectedSeats.size === 0;
        }

        function toggleSeatSelection(seatId) {
            const seatData = seatMap[seatId];
            if (seatData?.status !== 'available') return;
            
            if (selectedSeats.has(seatId)) {
                selectedSeats.delete(seatId);
            } else {
                selectedSeats.add(seatId);
            }
            
            // Re-render only affected seats for performance
            document.querySelectorAll(`.seat[data-seat-id="${seatId}"]`).forEach(el => {
                el.classList.toggle('selected', selectedSeats.has(seatId));
            });
            
            elements.holdBtn.disabled = selectedSeats.size === 0;
        }

        // ======================
        // API INTEGRATION
        // ======================
        async function refreshSeatStatus() {
            try {
                const status = await apiRequest(`/shows/${currentShowId}/seats`);
                
                // Update seat map
                seatMap = {};
                status.seats.forEach(seat => {
                    seatMap[seat.seat_id] = {
                        status: seat.status,
                        holdExpiresAt: seat.hold_expires_at
                    };
                });
                
                // Update stats
                elements.availableCount.textContent = status.available_seats;
                elements.heldCount.textContent = status.held_seats;
                elements.bookedCount.textContent = status.booked_seats;
                
                // Render grid
                renderSeatGrid();
                
                // Update holds list
                updateHoldsList();
                
                // Check invariants
                if (!status.invariants_valid) {
                    showToast('‚ö†Ô∏è System invariant violation detected!', 'error');
                    console.error('Invariant violation:', status);
                }
            } catch (error) {
                console.error('Failed to refresh seat status:', error);
            }
        }

        async function holdSelectedSeats() {
            if (selectedSeats.size === 0) return;
            
            try {
                const response = await apiRequest(`/shows/${currentShowId}/hold`, {
                    method: 'POST',
                    body: JSON.stringify({
                        seat_ids: Array.from(selectedSeats),
                        hold_duration_seconds: 600 // 10 minutes
                    })
                });
                
                currentHoldId = response.hold_id;
                holdExpiryTime = response.expires_at;
                
                // Clear selection
                selectedSeats.clear();
                renderSeatGrid();
                
                showToast(`‚úÖ Seats held! Expires in 10 minutes`, 'success');
                elements.bookBtn.disabled = false;
                elements.releaseBtn.disabled = false;
                
                // Auto-refresh to show hold status immediately
                await refreshSeatStatus();
            } catch (error) {
                showToast(`‚ùå Hold failed: ${error.message}`, 'error');
            }
        }

        async function bookHeldSeats() {
            if (!currentHoldId) return;
            
            try {
                const response = await apiRequest(`/shows/${currentShowId}/book`, {
                    method: 'POST',
                    body: JSON.stringify({ hold_id: currentHoldId })
                });
                
                showToast(`üéâ Booking confirmed! Booking ID: ${response.booking_id.substring(0, 8)}...`, 'success');
                currentHoldId = null;
                holdExpiryTime = null;
                elements.bookBtn.disabled = true;
                elements.releaseBtn.disabled = true;
                
                await refreshSeatStatus();
            } catch (error) {
                showToast(`‚ùå Booking failed: ${error.message}`, 'error');
                // Hold might have expired - refresh to update state
                await refreshSeatStatus();
            }
        }

        async function releaseHold() {
            if (!currentHoldId) return;
            
            try {
                await apiRequest(`/shows/${currentShowId}/release-hold`, {
                    method: 'POST',
                    body: JSON.stringify({ hold_id: currentHoldId })
                });
                
                showToast('üîÑ Hold released successfully', 'info');
                currentHoldId = null;
                holdExpiryTime = null;
                elements.bookBtn.disabled = true;
                elements.releaseBtn.disabled = true;
                
                await refreshSeatStatus();
            } catch (error) {
                showToast(`‚ùå Release failed: ${error.message}`, 'error');
            }
        }

        async function initializeNewShow() {
            const showId = elements.newShowId.value.trim();
            if (!showId) {
                showToast('‚ö†Ô∏è Please enter a show ID', 'error');
                return;
            }
            
            const layout = parseSeatLayout(elements.seatLayout.value);
            const seatIds = [];
            
            for (let row = 0; row < layout.rows; row++) {
                for (let col = 0; col < layout.cols; col++) {
                    seatIds.push(formatSeatId(row, col));
                }
            }
            
            try {
                await apiRequest(`/shows/${showId}/initialize`, {
                    method: 'POST',
                    body: JSON.stringify({ seat_ids: seatIds })
                });
                
                // Add to show selector
                const option = document.createElement('option');
                option.value = showId;
                option.textContent = `${showId} (${seatIds.length} seats)`;
                elements.showSelect.appendChild(option);
                elements.showSelect.value = showId;
                
                // Switch to new show
                currentShowId = showId;
                selectedSeats.clear();
                currentHoldId = null;
                holdExpiryTime = null;
                
                showToast(`‚úÖ Show "${showId}" initialized with ${seatIds.length} seats!`, 'success');
                await refreshSeatStatus();
            } catch (error) {
                showToast(`‚ùå Initialization failed: ${error.message}`, 'error');
            }
        }

        function updateHoldsList() {
            if (!holdExpiryTime || !currentHoldId) {
                elements.holdsList.innerHTML = '<div class="hold-item">No active holds</div>';
                return;
            }
            
            const timeRemaining = getTimeRemaining(holdExpiryTime);
            const isExpired = timeRemaining === 'Expired';
            
            elements.holdsList.innerHTML = `
                <div class="hold-item ${isExpired ? 'expired' : ''}">
                    <div class="hold-seats">Your hold: ${Array.from(selectedSeats).join(', ') || 'N/A'}</div>
                    <div class="hold-timer">${isExpired ? 'EXPIRED' : `Expires in: ${timeRemaining}`}</div>
                </div>
            `;
            
            if (isExpired) {
                currentHoldId = null;
                holdExpiryTime = null;
                elements.bookBtn.disabled = true;
                elements.releaseBtn.disabled = true;
            }
        }

        async function checkHealth() {
            try {
                const response = await fetch(`${API_BASE}/health`);
                const isHealthy = response.ok;
                elements.healthDot.className = `health-dot ${isHealthy ? 'healthy' : 'unhealthy'}`;
                elements.healthText.textContent = isHealthy ? 'System healthy' : 'System unhealthy';
                elements.healthText.style.color = isHealthy ? 'var(--available)' : 'var(--booked)';
            } catch (error) {
                elements.healthDot.className = 'health-dot unhealthy';
                elements.healthText.textContent = 'Health check failed';
                elements.healthText.style.color = 'var(--booked)';
            }
        }

        // ======================
        // CONCURRENCY SIMULATION
        // ======================
        async function simulateConcurrentUsers() {
            const logEntry = `[${new Date().toLocaleTimeString()}] Starting 10-user concurrency simulation...`;
            simulationLog.push(logEntry);
            updateSimulationLog();
            
            const results = [];
            const seatBatches = [
                ['A1'], ['A2'], ['A3'], ['A4'], ['A5'],
                ['B1'], ['B2'], ['B3'], ['B4'], ['B5']
            ];
            
            // Launch 10 concurrent requests
            const promises = seatBatches.map(async (seats, i) => {
                try {
                    const resp = await fetch(`${API_BASE}/shows/${currentShowId}/hold`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ seat_ids: seats, hold_duration_seconds: 30 })
                    });
                    
                    if (resp.ok) {
                        const data = await resp.json();
                        results.push({ user: i+1, success: true, seats: seats.join(', '), hold_id: data.hold_id.substring(0,8) + '...' });
                        return { success: true, user: i+1, seats: seats.join(', ') };
                    } else {
                        const err = await resp.json().catch(() => ({}));
                        results.push({ user: i+1, success: false, error: err.error || `HTTP ${resp.status}` });
                        return { success: false, user: i+1, error: err.error || `HTTP ${resp.status}` };
                    }
                } catch (error) {
                    results.push({ user: i+1, success: false, error: error.message });
                    return { success: false, user: i+1, error: error.message };
                }
            });
            
            // Wait for all to complete
            await Promise.allSettled(promises);
            
            // Log results
            const successCount = results.filter(r => r.success).length;
            const failCount = results.length - successCount;
            
            simulationLog.push(`‚úÖ ${successCount} users succeeded | ‚ùå ${failCount} users failed (race conditions handled safely)`);
            results.forEach(r => {
                simulationLog.push(`User ${r.user}: ${r.success ? `‚úÖ Booked ${r.seats}` : `‚ùå Failed: ${r.error}`}`);
            });
            simulationLog.push('='.repeat(50));
            updateSimulationLog();
            
            // Refresh to show new state
            await refreshSeatStatus();
        }

        function updateSimulationLog() {
            elements.simulationLog.textContent = simulationLog.slice(-50).join('\n');
            elements.simulationLog.scrollTop = elements.simulationLog.scrollHeight;
        }

        // ======================
        // EVENT LISTENERS
        // ======================
        elements.holdBtn.addEventListener('click', holdSelectedSeats);
        elements.bookBtn.addEventListener('click', bookHeldSeats);
        elements.releaseBtn.addEventListener('click', releaseHold);
        elements.refreshBtn.addEventListener('click', refreshSeatStatus);
        elements.simulateBtn.addEventListener('click', simulateConcurrentUsers);
        elements.initShowBtn.addEventListener('click', initializeNewShow);
        elements.showSelect.addEventListener('change', async (e) => {
            currentShowId = e.target.value;
            selectedSeats.clear();
            currentHoldId = null;
            holdExpiryTime = null;
            elements.bookBtn.disabled = true;
            elements.releaseBtn.disabled = true;
            await refreshSeatStatus();
        });

        // ======================
        // INITIALIZATION
        // ======================
        async function init() {
            // Initial data load
            await refreshSeatStatus();
            
            // Start auto-refresh
            refreshInterval = setInterval(refreshSeatStatus, 3000);
            
            // Start health checks
            setInterval(checkHealth, 5000);
            await checkHealth();
            
            // Setup keyboard shortcuts for power users
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    selectedSeats.clear();
                    renderSeatGrid();
                }
                if (e.key === 'Enter' && !elements.holdBtn.disabled) {
                    holdSelectedSeats();
                }
            });
            
            // Welcome message
            setTimeout(() => {
                showToast('‚úÖ System ready! Select seats to begin testing', 'success');
            }, 500);
        }

        // Start the app
        window.addEventListener('DOMContentLoaded', init);
        
        // Cleanup on unload
        window.addEventListener('beforeunload', () => {
            if (refreshInterval) clearInterval(refreshInterval);
        });
    </script>
</body>
</html>